<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="/main.af46ece4.css">
<script src="/main.af46ece4.js"></script></head>

<body>
    <!--DECLARE HTML ELEMENTS-->
    <div id="container"></div>

    <!--CALL THREE.JS MODULES-->
    <script src="/three.min.f31d536c.js"></script>
    <script src="/OrbitControls.86a60464.js"></script>
    <script src="/GLTFLoader.4a64ecb5.js"></script>

    <!--SHADERS GLSL FORMAT-->
    <script id="fragment-shader" type="x-shader/x-vertex">
        varying vec2 vCoordinates;
        varying vec3 vPos;
        uniform sampler2D flower;
        uniform sampler2D particle;
        uniform sampler2D mask;
        

        void main() 
        {
            vec4 maskTexture = texture2D(mask,gl_PointCoord);
            vec2 myUV = vec2(vCoordinates.x/512.,vCoordinates.y/512.);
            vec4 image = texture2D(particle, myUV);

            float alpha = 1. - clamp(0., 1., abs(vPos.z/900.));
            gl_FragColor= image;
            gl_FragColor.a *= maskTexture.r*alpha;

        }
    </script>

    <script id="vertex-shader" type="x-shader/x-vertex">
        varying vec2 vUv; 
        varying vec3 vPos; 
        varying vec2 vCoordinates;
        attribute vec3 aCoordinates;
        attribute float aSpeed;
        attribute float aOffset;
        attribute float aDirection; 
        attribute float aPress; 

        uniform float move;
        uniform float time;
        uniform vec2 mouse; 

        void main() 
        {
            vUv = uv; 
            vec3 pos = position;

             
            pos.x += sin(move*aSpeed)*20.;
            pos.y += sin(move*aSpeed)*20.;
            pos.z = mod(position.z + move*200.*aSpeed + aOffset, 2000.) -1000.;
            
            vec3 stable = position; 
            float dist = distance(stable.xy, mouse);
            float area = 1. - smoothstep(0.,300., dist);

            stable.x += 50. *sin(0.1*time*aPress)*aDirection*area;
            stable.y += 50. *sin(0.1*time*aPress)*aDirection*area;
            stable.z += 200. *cos(0.1*time*aPress)*aDirection*area;
      
            vec4 mvPosition = modelViewMatrix * vec4(stable, 1. );
            gl_PointSize= 5000. * (1. / -mvPosition.z);
            gl_Position= projectionMatrix * mvPosition;

            vCoordinates = aCoordinates.xy; 
            vPos = pos;
        }
    </script>


    <!--SET-UP THREEJS TEMPLATE-->
    <script>function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//declare Sketch set-up class
var Sketch = /*#__PURE__*/function () {
  function Sketch() {
    _classCallCheck(this, Sketch);

    // renderer settings- render window size
    this.renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(this.renderer.domElement); // camera properties

    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
    this.camera.position.z = 1500; // create new scene

    this.scene = new THREE.Scene(); //on mouse click

    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();
    this.point = new THREE.Vector2(); //this.mask = new THREE.TextureLoader().load(mask);

    this.time = 0;
    this.move = 0;
    this.addMesh();
    this.mouseEffects();
    this.render();
  } // CONTROLS


  _createClass(Sketch, [{
    key: "mouseEffects",
    value: function mouseEffects() {
      var _this = this;

      this.test = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshBasicMaterial()); //on wheel scroll

      window.addEventListener('mousewheel', function (e) {
        console.log(e.wheelDeltaY);
        _this.move += e.wheelDeltaY / 1000;
      }); //on mouse click

      window.addEventListener('mousemove', function (event) {
        _this.mouse.x = event.clientX / window.innerWidth * 2 - 1;
        _this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        _this.raycaster.setFromCamera(_this.mouse, _this.camera); // calculate any objects intersecting with the mouse click
        // array needed between parantheses


        var intersects = _this.raycaster.intersectObjects([_this.test]);

        _this.point.x = intersects[0].point.x;
        _this.point.y = intersects[0].point.y;
      }, false);
    }
  }, {
    key: "addMesh",
    value: function addMesh() {
      // textures
      //var mask = this.mask;
      var flower = new THREE.TextureLoader().load('/images/flower.png');
      var particle = new THREE.TextureLoader().load('/images/particle.png');
      this.textures = [flower, particle]; // declare materials

      this.material = new THREE.ShaderMaterial({
        vertexShader: document.getElementById('vertex-shader').textContent,
        fragmentShader: document.getElementById('fragment-shader').textContent,
        uniforms: {
          progress: {
            type: "f",
            value: 0
          },
          particle: {
            type: "t",
            value: this.textures[0]
          },
          flower: {
            type: "t",
            value: this.textures[1]
          },
          //mask: {type:"t", value: this.mask[1]},
          mouse: {
            type: "v2",
            value: null
          },
          move: {
            type: "f",
            value: 0
          },
          time: {
            type: "f",
            value: 0
          }
        },
        side: THREE.DoubleSide,
        transparent: true,
        depthTest: false,
        depthWrite: false
      }); // particles

      var number = 512 * 512;
      this.geometry = new THREE.BufferGeometry();
      this.positions = new THREE.BufferAttribute(new Float32Array(number * 3), 3);
      this.coordinates = new THREE.BufferAttribute(new Float32Array(number * 3), 3);
      this.speeds = new THREE.BufferAttribute(new Float32Array(number), 1);
      this.offset = new THREE.BufferAttribute(new Float32Array(number), 1);
      this.direction = new THREE.BufferAttribute(new Float32Array(number), 1);
      this.press = new THREE.BufferAttribute(new Float32Array(number), 1); // set random speeds for particles

      function rand(a, b) {
        return a + (b - a) * Math.random();
      }

      var index = 0;

      for (var i = 0; i < 512; i++) {
        var posX = i - 256;

        for (var j = 0; j < 512; j++) {
          this.positions.setXYZ(index, posX * 2, (j - 256) * 2, 0);
          this.coordinates.setXYZ(index, i, j, 0);
          this.offset.setX(index, rand(-1000, 1000));
          this.speeds.setX(index, rand(0.4, 1));
          this.direction.setX(index, Math.random() > 0.5 ? 1 : -1);
          this.press.setX(index, rand(0.4, 1));
          index++;
        }
      }

      this.geometry.setAttribute("position", this.positions);
      this.geometry.setAttribute("aCoordinates", this.coordinates);
      this.geometry.setAttribute("aSpeed", this.speeds);
      this.geometry.setAttribute("aOffset", this.offset);
      this.geometry.setAttribute("aDirection", this.direction);
      this.geometry.setAttribute("aPress", this.press); // create particles

      this.mesh = new THREE.Points(this.geometry, this.material);
      this.scene.add(this.mesh); //this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    }
  }, {
    key: "render",
    value: function render() {
      this.time++;
      this.material.uniforms.time.value = this.time;
      this.material.uniforms.move.value = this.move;
      this.material.uniforms.mouse.value = this.point;
      this.renderer.render(this.scene, this.camera);
      window.requestAnimationFrame(this.render.bind(this));
    }
  }]);

  return Sketch;
}();

new Sketch();</script>

</body>

</html>